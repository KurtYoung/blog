title: Kappa Architecture - 《Questioning the Lambda Architecture》
date: 2016-01-16 19:24:15
tags:
	- architecture
	- 笔记
---
原文链接：http://radar.oreilly.com/2014/07/questioning-the-lambda-architecture.html

# 前言
在上一篇介绍[Lambda Architecture](/2016/01/09/lambda-architecture/)的文章中，作者提出了一种号称能“击败”CAP理论的系统架构，这个架构现在整变得越来越流行，甚至已经有专门的[网站](http://lambda-architecture.net/)和[书](http://www.manning.com/marz/)。本文是当时还在Linkedin的大神Jay Kreps写的他对这个架构的一些观点，并且提出了一种他认为比较靠谱的可选方案。

# Lambda Architecture回顾
这种系统看起来一般长这个样子：
![](images/lambda.png)
系统从一个流中读取被我们定义为不可变的数据，分别灌入实时和批处理系统，然后各自输出自己的结果。在查询端，对实时和批处理的结果进行合并。这种系统还有许多变种，比如选择各种各样的分布式队列，流计算引擎。	或者同时使用多个存储引擎，一种适合批量存储，一种适合流式存储。这种系统主要面向的场景主要是逻辑比较复杂同时又希望延迟比较低的异步处理程序，比如搜索引擎，推荐引擎等。
<!-- more -->
# Lambda Architecture的优点：
将数据定义为不可变是Lambda Architecture一个很好的起点，同时把复杂的数据处理分成多个不同的阶段，在他们之间使用数据作为桥梁这种做法也有很多好处。比较明显的就是系统解耦，你可以独立的对每一步进行设计和实现。另外Lambda Architecture强调了一个别人经常忽视的问题，那就是全量数据的重新处理。数据全量重新处理能解决很多问题，比如代码逻辑升级，老代码有bug等。许多人设计流式处理系统经常会忽略这个功能的重要性。
另外一些Lambda Architecture提出的观点可能就不是非常有道理了。比如认为实时处理系统一般比较弱，比不上批处理等。这些现象可能只是现在的实时处理系统还没有MapReduce这种发展了好多年的系统成熟罢了。另外一点是号称自己“击败”了CAP理论，这看起来也只是一个文字游戏，CAP理论依然成立，作者只是提出了一个异步处理系统的架构同时做了一些有效性和延迟的取舍。

# Lambda Architecture的缺点：
Lambda Architecture的一个明显的问题是，我们需要维护两套分别跑在批处理和实时计算系统上面的代码，而且这两套代码得产出一模一样的结果。一般批处理和实时计算系统都会有各自适合自己的接口API，我们写出的代码不可避免的会往不同的方向发展。一个解决办法是，提供一个更高的抽象层，将这两种计算框架隐藏在抽象之后，比如[Summingbird](http://github.com/twitter/summingbird)。虽然这样做能缓解这个问题，但不能彻底解决，设计和维护这样的抽象本身就是个很恶心的事情了。就算我们想出了一种办法来决绝两套代码的问题，我们始终还得面对两个在运行的系统，运维成本还是比较高。同时Jay大神还说了他们在Linkedin还真就做了这么件事（估计就是上面提到的Summingbird），这种系统能用，但确实不怎么爽。虽然做了高层次抽象的本意是对用户屏蔽实现细节，但用户想真正用好这样的系统，却需要知道更多的批处理和实时计算的细节，你总得知道API是如何转换到批处理和实时计算的，不然系统出故障的时候就只能抓瞎了。
所以，我们其实不妨在选择系统的时候简单点，你能容忍高延迟，需要大吞吐，你就选择像Hadoop这样的批处理系统。如果你需要低延时，那就选择实时计算系统。Lambda Architecture如此流行的一个原因是，大家可能越来越需要一种能应对流程复杂，低延迟，大吞吐的系统。Lambda Architecture做法只是简单的将两种处理能力和特点各不相同的系统结合在了一块，这并不一定就能代表未来大数据处理系统的发展方向，而且我们目前也可以有一种替代的方案。

# 替代方案：Kappa Architecture
对于设计这类系统的人来讲，一个要面对的问题是：为什么我们不能改进流计算系统让它能处理这些问题？为什么不能让流计算系统来解决数据全量处理的问题？流计算天然的分布式特性注定了其扩展性比较好，我们能不能加大并发量来处理海量的历史数据？Jay认为这其实就是一个比较靠谱的替代方案。
可能大家看到这个的时候，都会下意识的觉得让流计算系统来处理海量数据会有点不合适，要么吞吐量会上不去，又或者是系统的规模上不去。流计算给人的印象大部分还是对一些流式的，临时的数据进行计算，将结果保存后就把原始数据给扔了。但流计算的本质其实是数据流的DAG，这和各种批处理，海量计算系统并没有什么区别。像MapReduce这样流行的批处理系统也仍然有个改进的更像DAG处理的版本:[Tez](http://hortonworks.com/hadoop/tez/)。流计算只是对这种数据模型进行了抽象和概括，同时引入了在中间结果集上进行checkpoint，并持续将结果输出给用户的概念。
那么我们怎么对全量数据进行重新计算？答案也很简单：

1. 用Kafka或者类似的分布式队列系统保存数据，你需要几天的数据量就保存几天。
2. 当需要全量重新计算时，重新起一个流计算实例，从头开始读取数据进行处理，并输出到一个新的结果存储中。
3. 当新的实例做完后，停止老的流计算实例，并把老的一些结果删除。

这种架构看起来长这个样子：
![](images/kappa.png)
和Lambda Architecture不同的是，在这种架构下，我们只有在必要的时候才会对数据进行重复计算，并且系统的结构，使用的代码，读取的数据都和老版本一样。而且在必要的时候，我们还可以控制新实例的并发数，让全量的计算尽快的完成。

这就是**Kappa Architecture**，看起来比Lambda架构还要简单一些。

上面的架构图里，新老实例各使用了自己的结果存储。虽然我们可以对这个进行优化，让它们共享一个结果存储，但同时保留多个结果也是有它的好处的（毕竟它们只是短暂的同时存在）。存两份结果的好处是，我们可以随时的进行回滚。更进一步，假如我们产出的是一些算法模型之类的数据，用户还可以同时对新老两份数据进行效果验证，做一些A/B test或者使用bandit算法来最大限度的使用这些数据。

# 两个架构的对比
Kappa架构吸收了不少Lambda架构提出的观点和假设，Jay表示Kappa Architecture在Linkedin已经进行了大规模的使用，并且效果还不错。两个架构有各自的优点，也有各自的缺点。Lamda架构需要批处理和全量计算一直跑着，而Kappa架构只在需要的时候才进行全量计算。但Kappa架构需要更多的结果存储，不过如果你有很多这样的系统，并且跑在一个共享集群上，这些临时的额外开销影响也不是很大。也许真正的对比并不是这两个架构谁的效率更高，而是用户能不能轻松的在这种架构上进行开发，测试和运维，并且只需要面对一个框架。





